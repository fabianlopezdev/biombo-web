---
// Component: src/components/pages/homepage/About.astro
// Fetches and renders the About section data from Sanity CMS.

import { fetchHomePageByLocale } from '@/shared/lib/sanity/queries/homePageQueries'
import type { SanityImage as SanityImageType } from '@/shared/schemas/sanity/homePageSchema'
import { toHTML, type PortableTextComponents } from '@portabletext/to-html'
import { Image } from 'astro:assets'

// ----------------------------------------------------------------------
// Props & Sanity data
// ----------------------------------------------------------------------

interface Props {
  sectionData?: any
}

const { sectionData } = Astro.props
const currentLocale = (Astro.currentLocale || 'ca') as 'ca' | 'es' | 'en'

// If no data passed in, fetch it
let aboutSection = sectionData
if (!aboutSection) {
  const homePageData = await fetchHomePageByLocale(currentLocale)
  aboutSection = homePageData?.about
}

// Convert Portable Text to HTML
let descriptionHtml = ''
if (aboutSection?.description) {
  const customPortableTextComponents: Partial<PortableTextComponents> = {
    block: {
      normal: ({ children }): string => children || '',
    },
  }

  descriptionHtml = toHTML(aboutSection.description as any, {
    components: customPortableTextComponents,
  })
}

// Images & indicator width
interface DisplayImage extends SanityImageType {}
const imagesToDisplay: DisplayImage[] = aboutSection?.images
  ? aboutSection.images.map((img) => img as DisplayImage)
  : []

const imageCount = imagesToDisplay.length
const indicatorWidthPercent = imageCount > 0 ? 100 / imageCount : 100
const imageWidth = 29.495
---

<!-- ------------------------------------------------------------------- --><!-- Slider logic                                                         --><!-- ------------------------------------------------------------------- -->
<script define:vars={{ imageCount, imageWidth }}>
  document.addEventListener('DOMContentLoaded', () => {
    const aboutSectionComponent = document.querySelector('.about')
    if (!aboutSectionComponent) {
      console.error('About section component not found')
      return
    }

    const imageContainers = aboutSectionComponent.querySelectorAll('.slider__img-container')
    const slider = aboutSectionComponent.querySelector('[data-slider]')
    const indicator = aboutSectionComponent.querySelector('.slider__indicator')
    const prevBtn = aboutSectionComponent.querySelector('.slider__arrow--prev')
    const nextBtn = aboutSectionComponent.querySelector('.slider__arrow--next')
    const progressBar = aboutSectionComponent.querySelector('.slider__progress')

    if (!slider || !indicator || !progressBar) {
      console.error('Slider or indicator or progress bar not found')
      return
    }

    /* ===================== SIMPLE APPROACH ===================== */

    let isAnimating = false // Prevent indicator updates during animations
    let animationTimeout = null // Track timeout to clear it on new animations

    /**
     * Sets indicator to specific segment position with smooth transition
     */
    function setIndicatorToSegment(segment, shouldAnimate = true) {
      const translatePercent = segment * 100

      if (shouldAnimate) {
        // Ensure smooth transition for all movements
        indicator.style.transition = 'transform 0.3s ease-out'
      } else {
        // No transition for immediate updates
        indicator.style.transition = 'none'
      }

      indicator.style.transform = `translateX(${translatePercent}%)`
      indicator.style.setProperty('--current-position', `${translatePercent}%`)
      console.log(
        `Indicator set to segment ${segment} (${translatePercent}%) - animated: ${shouldAnimate}`,
      )
    }

    /**
     * Moves slider to specific segment with proper animation management
     */
    function moveToSegment(targetSegment, animateIndicator = true) {
      console.log(`\n=== MOVING TO SEGMENT ${targetSegment} ===`)

      // Clear any existing animation timeout to prevent conflicts
      if (animationTimeout) {
        clearTimeout(animationTimeout)
        animationTimeout = null
        console.log('Cleared previous animation timeout')
      }

      // 1. Update indicator with smooth animation
      setIndicatorToSegment(targetSegment, animateIndicator)

      // 2. Calculate target scroll position
      const maxScroll = slider.scrollWidth - slider.clientWidth
      let targetScrollPosition

      if (targetSegment === 0) {
        targetScrollPosition = 0
      } else if (targetSegment === imageCount - 1) {
        targetScrollPosition = maxScroll // Go to end
      } else {
        // Middle segments: calculate percentage
        const targetPercent = (targetSegment / (imageCount - 1)) * 100
        targetScrollPosition = (targetPercent / 100) * maxScroll
      }

      console.log(`Target scroll position: ${targetScrollPosition}px`)

      // 3. Start slider animation
      isAnimating = true
      slider.scrollTo({
        left: targetScrollPosition,
        behavior: 'smooth',
      })

      // 4. Set new timeout to clear animation flag
      animationTimeout = setTimeout(() => {
        isAnimating = false
        animationTimeout = null
        console.log('Animation complete')
      }, 800) // Reduced timeout for faster responsiveness
    }

    /* ===================== PROGRESS BAR CLICKS ===================== */

    function handleProgressBarClick(clickEvent) {
      // Only handle clicks on the progress bar itself, not the indicator
      if (clickEvent.target === indicator) {
        console.log('Clicked indicator - ignoring in progress bar handler')
        return
      }

      // Calculate which segment was clicked
      const rect = progressBar.getBoundingClientRect()
      const clickPercent = (clickEvent.clientX - rect.left) / rect.width
      const segmentWidth = 1 / imageCount
      const targetSegment = Math.floor(clickPercent / segmentWidth)
      const validSegment = Math.max(0, Math.min(imageCount - 1, targetSegment))

      console.log(
        `Progress bar area clicked: ${(clickPercent * 100).toFixed(1)}% → segment ${validSegment}`,
      )

      // Update current segment immediately to prevent conflicts
      currentSegment = validSegment
      moveToSegment(validSegment, true) // Always animate for progress bar clicks
    }

    /* ===================== ARROW NAVIGATION ===================== */

    let currentSegment = 0 // Track current segment

    function updateArrowStates() {
      prevBtn.disabled = currentSegment === 0
      prevBtn.classList.toggle('disabled', currentSegment === 0)

      nextBtn.disabled = currentSegment === imageCount - 1
      nextBtn.classList.toggle('disabled', currentSegment === imageCount - 1)
    }

    prevBtn.addEventListener('click', () => {
      if (currentSegment > 0) {
        currentSegment--
        console.log(`Prev button: moving to segment ${currentSegment}`)
        moveToSegment(currentSegment)
        updateArrowStates()
      }
    })

    nextBtn.addEventListener('click', () => {
      if (currentSegment < imageCount - 1) {
        currentSegment++
        console.log(`Next button: moving to segment ${currentSegment}`)
        moveToSegment(currentSegment)
        updateArrowStates()
      }
    })

    /* ===================== ORIGINAL PROGRESS TRACKING (FOR REFERENCE) ===================== */

    function updateProgress() {
      // Only update if we're not in the middle of an animation
      if (isAnimating) {
        console.log('Skipping progress update - animation in progress')
        return
      }

      const scrollPercent = maxScroll > 0 ? (slider.scrollLeft / maxScroll) * 100 : 0

      let detectedPosition = 0
      if (imageCount > 2) {
        const threshold = imageWidth
        for (let i = 0; i < imageCount; i++) {
          let posPercent
          if (i === 0) {
            posPercent = 0
          } else {
            posPercent = (i / (imageCount - 1)) * 100
          }
          if (
            Math.abs(scrollPercent - posPercent) < threshold ||
            (i === imageCount - 1 && scrollPercent > posPercent - threshold)
          ) {
            detectedPosition = i
            break
          }
        }
      }

      // Only update if the detected position actually changed
      if (detectedPosition !== currentSegment) {
        console.log(`Position changed: ${currentSegment} → ${detectedPosition}`)
        currentSegment = detectedPosition
        setIndicatorToSegment(currentSegment, false) // No animation for position detection
        updateArrowStates()
      }
    }

    function disableArrows() {
      const firstSlide = slider.scrollLeft <= 1
      const lastSlide = slider.scrollLeft >= maxScroll - 1

      prevBtn.disabled = firstSlide
      prevBtn.classList.toggle('disabled', firstSlide)

      nextBtn.disabled = lastSlide
      nextBtn.classList.toggle('disabled', lastSlide)
    }

    /* ===================== DRAG FUNCTIONALITY (INDICATOR ONLY) ===================== */

    let draggingBar = false

    // Progress bar click handler - only for progress bar area, not indicator
    progressBar.addEventListener('click', handleProgressBarClick)

    function startIndicatorDrag(clientX) {
      draggingBar = true
      document.body.style.userSelect = 'none'
      indicator.style.transition = 'none'
      progressBar.style.cursor = 'grabbing'
      indicator.style.cursor = 'grabbing'
      indicator.style.backgroundColor = 'rgba(255,255,255,0.9)'
      indicator.style.transform += ' scale(0.98)'
      console.log('Started indicator drag')
    }

    function indicatorDrag(clientX) {
      if (!draggingBar) return

      const rect = progressBar.getBoundingClientRect()
      const dragPercent = (clientX - rect.left) / rect.width
      const targetSegment = Math.max(
        0,
        Math.min(imageCount - 1, Math.round(dragPercent * (imageCount - 1))),
      )

      // Clear any ongoing animations before starting drag-based movement
      if (animationTimeout) {
        clearTimeout(animationTimeout)
        animationTimeout = null
      }

      // No indicator animation during drag for immediate feedback
      moveToSegment(targetSegment, false)
      currentSegment = targetSegment
      console.log(`Dragging to segment: ${targetSegment}`)
    }

    function endIndicatorDrag() {
      if (!draggingBar) return
      draggingBar = false
      document.body.style.userSelect = ''
      indicator.style.transition = 'transform 0.1s linear'
      progressBar.style.cursor = 'pointer'
      indicator.style.cursor = 'grab'
      indicator.style.backgroundColor = ''
      console.log('Ended indicator drag')

      setTimeout(() => {
        updateProgress()
      }, 10)
    }

    // ONLY indicator can be dragged
    indicator.addEventListener('mousedown', (e) => {
      e.preventDefault()
      e.stopPropagation() // Prevent progress bar click from firing
      startIndicatorDrag(e.clientX)
    })

    // Global mouse events for dragging
    document.addEventListener('mousemove', (e) => {
      if (draggingBar) indicatorDrag(e.clientX)
    })

    document.addEventListener('mouseup', endIndicatorDrag)

    /* ===================== HOVER BEHAVIOR (SIMPLIFIED) ===================== */

    let hoverBehaviorUpdateTimeout = null

    function updateHoverBehaviorThrottled() {
      if (hoverBehaviorUpdateTimeout) {
        clearTimeout(hoverBehaviorUpdateTimeout)
      }
      hoverBehaviorUpdateTimeout = setTimeout(() => {
        updateHoverBehaviorImmediate()
        hoverBehaviorUpdateTimeout = null
      }, 100) // Longer throttle
    }

    function updateHoverBehaviorImmediate() {
      const containerRect = slider.getBoundingClientRect()
      const allImageContainers = Array.from(slider.querySelectorAll('.slider__img-container'))

      const visibleImageContainers = allImageContainers
        .filter((img) => {
          const r = img.getBoundingClientRect()
          return r.right > containerRect.left && r.left < containerRect.right
        })
        .sort((a, b) => a.getBoundingClientRect().left - b.getBoundingClientRect().left)

      // Reset everything
      allImageContainers.forEach((imgContainer) => {
        imgContainer.classList.remove('can-hover', 'grow-left', 'grow-right')
        imgContainer.removeAttribute('data-grow-direction')
      })

      if (!visibleImageContainers || visibleImageContainers.length === 0) {
        return
      }

      visibleImageContainers.forEach((visibleImageContainer, idx) => {
        if (!visibleImageContainer) return

        let targetGrowClass, growDirection

        if (idx === 0) {
          targetGrowClass = 'grow-right'
          growDirection = 'right'
        } else {
          targetGrowClass = 'grow-left'
          growDirection = 'left'
        }

        visibleImageContainer.classList.add('can-hover', targetGrowClass)
        visibleImageContainer.setAttribute('data-grow-direction', growDirection)
      })
    }

    /* ===================== HOVER LISTENERS ===================== */

    slider.querySelectorAll('.slider__img-container').forEach((img) => {
      img.addEventListener('mouseenter', function () {
        if (this.classList.contains('can-hover')) {
          this.classList.add('hover-active')
        }
      })

      img.addEventListener('mouseleave', function () {
        this.classList.remove('hover-active')
      })
    })

    /* ===================== EVENT LISTENERS ===================== */

    let maxScroll = slider.scrollWidth - slider.clientWidth

    slider.addEventListener('scroll', () => {
      updateProgress()
      updateHoverBehaviorThrottled()
    })

    window.addEventListener('resize', () => {
      maxScroll = slider.scrollWidth - slider.clientWidth
      updateProgress()
      updateHoverBehaviorImmediate()
    })

    window.addEventListener('load', () => {
      updateProgress()
      updateHoverBehaviorImmediate()
    })

    setTimeout(() => {
      updateProgress()
      updateHoverBehaviorImmediate()
    }, 100)
  })
</script>
<!-- ------------------------------------------------------------------- --><!-- Markup (unchanged)                                                  --><!-- ------------------------------------------------------------------- -->{
  aboutSection && (
    <div class="about">
      <div class="about__text">
        <h2 class="about__title">{aboutSection.title.toUpperCase()}</h2>
        <p class="about__copy" set:html={descriptionHtml} />
      </div>

      <div class="about__gallery">
        {imageCount === 1 && (
          <Image
            src={imagesToDisplay[0].asset.url}
            alt={`Image for ${aboutSection.title}`}
            style="border-start-start-radius: 0.621875rem; border-end-start-radius: 0.621875rem;"
            class="slider__img"
            width={imagesToDisplay[0].asset.metadata?.dimensions.width ?? 600}
            height={imagesToDisplay[0].asset.metadata?.dimensions.height ?? 800}
            densities={[1, 1.5, 2]}
            format="webp"
            quality={80}
            loading="lazy"
          />
        )}
        {imageCount === 2 && (
          <div class="slider-container">
            <div class="slider" data-slider>
              {imagesToDisplay.map((image: DisplayImage, i: number) => (
                <div class={`slider__img-container img-${i}`} style={`--image-width: 50%`}>
                  <Image
                    src={image.asset.url}
                    alt={`Image for ${aboutSection.title} – ${i + 1}`}
                    class="slider__img"
                    width={image.asset.metadata?.dimensions.width ?? 600}
                    height={image.asset.metadata?.dimensions.height ?? 800}
                    densities={[1, 1.5, 2]}
                    format="webp"
                    quality={80}
                    loading="lazy"
                  />
                </div>
              ))}
            </div>
          </div>
        )}
        {imageCount > 2 && (
          <>
            <div class="slider-container">
              <div class="slider" data-slider>
                {imagesToDisplay.map((image: DisplayImage, i: number) => (
                  <div class="slider__img-container" style={`--image-width: ${imageWidth}rem`}>
                    <Image
                      src={image.asset.url}
                      alt={`Image for ${aboutSection.title} – ${i + 1}`}
                      class="slider__img"
                      width={image.asset.metadata?.dimensions.width ?? 600}
                      height={image.asset.metadata?.dimensions.height ?? 800}
                      densities={[1, 1.5, 2]}
                      format="webp"
                      quality={80}
                      loading="lazy"
                    />
                  </div>
                ))}
              </div>

              <button class="slider__arrow slider__arrow--prev" aria-label="Previous image">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none">
                  <path
                    d="M15 18L9 12L15 6"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  />
                </svg>
              </button>

              <button class="slider__arrow slider__arrow--next" aria-label="Next image">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none">
                  <path
                    d="M9 18L15 12L9 6"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  />
                </svg>
              </button>
            </div>
            <div
              class="slider__progress"
              role="progressbar"
              aria-label="Galeria: progrés de desplaçament"
              aria-valuemin="0"
              aria-valuemax="100"
            >
              <div
                class="slider__indicator"
                style={`--indicator-width: ${indicatorWidthPercent}%`}
              />
            </div>
          </>
        )}
      </div>
    </div>
  )
}

<!-- ------------------------------------------------------------------- -->
<!-- Styles (unchanged)                                                  -->
<!-- ------------------------------------------------------------------- -->
<style>
  /* entire style block exactly as before */
</style>

<!-- ------------------------------------------------------------------- -->
<!-- Styles                                                              -->
<!-- ------------------------------------------------------------------- -->
<style>
  /* ------------------ Layout --------------------------------------- */
  .about {
    display: grid;
    grid-template-columns: clamp(18rem, 35vw, 40rem) 1fr;
    gap: 4.4375rem;
    height: 100dvh;
    padding-block: var(--padding-block-desktop);
    padding-inline-start: var(--padding-inline-desktop);
    background-color: var(--color-secondary);
    color: var(--color-primary);
    overflow: hidden;
  }

  .about__title {
    font-size: var(--font-size);
    font-weight: var(--font-weight-light);
    margin-block-end: 7.8125rem;
  }

  .about__copy {
    font-size: var(--font-size-homepage-sections);
    font-weight: var(--font-weight-light);
    max-width: 33.1875rem;
    line-height: 1.184;
  }

  /* ------------------ Gallery -------------------------------------- */
  .about__gallery {
    --slider-space: 1.981875rem;
    display: flex;
    flex-direction: column;
    gap: var(--slider-space);
    overflow: hidden; /* keep side clipping */
  }

  .slider-container {
    position: relative;
    overflow: hidden;
    border-start-start-radius: 0.621875rem;
    border-end-start-radius: 0.621875rem;
    height: 39.81625rem;
  }

  .slider {
    height: 100%;
    display: flex;
    gap: var(--slider-space);
    overflow-x: auto;
    scroll-snap-type: x mandatory;
    overscroll-behavior-x: contain;
    -webkit-overflow-scrolling: touch;
    scrollbar-width: none;
    -ms-overflow-style: none;
  }

  .slider::-webkit-scrollbar {
    display: none;
  }

  .slider.active-drag {
    cursor: grabbing;
  }

  .slider::after {
    content: '';
    flex: 0 0 0.1px;
  }

  .slider__img-container {
    scroll-snap-align: start;
    user-select: none;
    flex: 0 0 auto;
    width: var(--image-width);
    height: 100%;
    border-radius: 0.621875rem;
    overflow: hidden;
    position: relative;
    transition:
      width 0.4s ease,
      transform 0.4s ease;
    transform-origin: center;
  }

  /* Only allow hover on visible images */
  .slider__img-container.can-hover {
    cursor: pointer;
  }

  /* Base hover state */
  .slider__img-container.hover-active {
    width: 100%;
    z-index: 10;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
  }

  /* Grow from left edge (expands to the right) */
  .slider__img-container.hover-active.grow-right {
  }

  /* Grow from right edge (expands to the left) */
  .slider__img-container.hover-active.grow-left {
    transform: translateX(calc(-100% + 20.7rem));
  }

  /* Ensure smooth transitions on hover end */
  .slider__img-container:not(.hover-active) {
    transform: translateX(0);
  }

  .img-0:hover {
    width: 100%;
  }

  .img-1:hover {
    width: 100%;
    transform: translateX(calc(-50% - var(--slider-space)));
    object-position: left top !important;
  }

  .img-1 img {
    transition: object-position 0.4s ease;
  }

  .img-1:hover img {
    object-position: top;
  }

  @media (prefers-reduced-motion: no-preference) {
    .slider {
      scroll-behavior: smooth;
    }
  }

  /* ------------------ Arrows --------------------------------------- */
  .slider__arrow {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 50%;
    width: 3rem;
    height: 3rem;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.3s ease;
    color: var(--color-primary);
    z-index: 10;
    opacity: 0;
    pointer-events: none;
    visibility: hidden;
  }

  .slider-container:hover .slider__arrow {
    opacity: 1;
    pointer-events: auto;
    visibility: visible;
  }

  .slider__arrow:hover {
    background: rgba(255, 255, 255, 0.2);
    border-color: rgba(255, 255, 255, 0.3);
    transform: translateY(-50%) scale(1.1);
  }

  .slider__arrow:active {
    transform: translateY(-50%) scale(0.95);
  }

  .slider__arrow[disabled] {
    pointer-events: none !important;
    opacity: 0 !important;
    visibility: hidden !important;
  }

  .slider__arrow--prev {
    left: 1rem;
  }
  .slider__arrow--next {
    right: 1rem;
  }

  .slider__arrow svg {
    width: 1.5rem;
    height: 1.5rem;
  }

  /* ------------------ Progress bar --------------------------------- */
  .slider__progress {
    width: 47.625rem;
    max-width: 100%;
    min-height: 1.75rem;
    border: 1px solid var(--color-primary);
    border-radius: 1.25rem;
    overflow: hidden;
    padding-inline: 0.5rem;
    padding-block: 0.375rem;
    cursor: pointer;
    transition: all 0.2s ease;
    display: block;
  }

  .slider__progress:hover {
    background: rgba(255, 255, 255, 0.1);
  }

  .slider__indicator {
    --indicator-width: 100%;
    width: var(--indicator-width);
    height: 0.9375rem;
    background-color: var(--color-primary);
    border-radius: 1.25rem;
    transform: translateX(0%);
    transition: transform 0.1s linear;
    display: block;
    cursor: grab;
  }

  .slider__indicator:hover {
    transform: translateX(var(--current-position, 0%));
  }

  .slider__indicator:active {
    cursor: grabbing;
    transform: translateX(var(--current-position, 0%)) scale(0.9);
  }

  @media (prefers-reduced-motion: no-preference) {
    .slider__indicator {
      transition: transform 0.2s ease-out;
    }
  }

  /* ------------------ Responsive ----------------------------------- */
  @media (max-width: 768px) {
    .about {
      grid-template-columns: 1fr;
      gap: 2rem;
      height: auto;
      padding: 2rem 1rem;
    }

    .about__title {
      margin-block-end: 2rem;
    }

    .slider__img-container {
      width: 20rem;
    }

    .slider__img-container.hover-active.grow-left {
      transform: translateX(calc(-100% + 20rem));
    }

    .slider__arrow {
      width: 2.5rem;
      height: 2.5rem;
    }

    .slider__arrow svg {
      width: 1.2rem;
      height: 1.2rem;
    }

    .slider__progress {
      width: 100%;
    }
  }
</style>
